"
This class defines AST node menus for conditional  breakpoints
"
Class {
	#name : #SugsBreakConditionSuggestion,
	#superclass : #SugsBreakpointSuggestion,
	#category : #'SmartSuggestions-Suggestion'
}

{ #category : #breakpoints }
SugsBreakConditionSuggestion >> breakpointForCondition [
	(UIManager default 
		request: 'Break on what condition?
- This expression will be evaluated in the context of the position of this breakpoint
- `thisContext` and `self` work as you would expect
- `ThisContext` is an alias for `thisContext`
- := and accessing Pool variables are not supported'
		initialAnswer: 'true'
	)	
		ifNotNil: [ :condition | Breakpoint new 
			node: context selectedNode;
			condition: (self conditionStringToConditionBlock: condition);
			install]
]

{ #category : #breakpoints }
SugsBreakConditionSuggestion >> conditionStringToConditionBlock: aString [
	| conditionAST conditionBlockProducerMethodAST conditionBlock |
	conditionAST := RBParser parseExpression: aString.
	conditionBlockProducerMethodAST := 
		RBMethodNode 
			selector: #conditionBlockGenerator
			body: (
				RBReturnNode value: (
					RBBlockNode 
						arguments: {RBVariableNode named: 'ThisContext'}
						body: (
							RBMessageNode
								receiver: (RBVariableNode named: 'Breakpoint')
								selector: #checkBreakConditionValue:
								arguments: { conditionAST }) asSequenceNode
						)
				) asSequenceNode.
	conditionBlockProducerMethodAST := self rewriteASTToSimulateExecutionInADifferentContext: conditionBlockProducerMethodAST.
	"The following commented code is a failed attempt at adding a comment to the conditionBlockProducerMethod source code, saying that it is autogenerated and that modifying it is pointless."
	"conditionBlockProducerMethodAST comments: {RBComment with: 'Auto generated' at: (conditionBlockProducerMethodAST selector size)}."
	"Setting a source code for the AST, so that inspecting it, for example after an exception occured, works."
	conditionBlockProducerMethodAST source: conditionBlockProducerMethodAST formattedCode.
	conditionBlock := (conditionBlockProducerMethodAST generateWithSource) valueWithReceiver: nil arguments: {}.
	^ conditionBlock.
]

{ #category : #execution }
SugsBreakConditionSuggestion >> execute [
	context hasUnacceptedEdits ifTrue: [ ^context sourceTextArea acceptEdits].
	
	self selectedNodeHasBreakpoint 
		ifFalse: [ self breakpointForCondition ]
		ifTrue: [ Breakpoint removeFrom: context selectedNode]
]

{ #category : #execution }
SugsBreakConditionSuggestion >> isValidForContext [
	^self selectedNodeHasBreakpoint not and: [self hasUnacceptedEdits not and:[ super isValidForContext ]]
]

{ #category : #accessing }
SugsBreakConditionSuggestion >> label [
	^'Break on condition' translated
]

{ #category : #execution }
SugsBreakConditionSuggestion >> rewriteASTToSimulateExecutionInADifferentContext: anAST [
	| semanticallyAnalysedMethodAST allUndeclaredVariableNodes allUndeclaredVariableSymbols rewriter rewrittenConditionBlockProducerAST |
	"AnAST is the AST of a method returning a block taking a context as its argument named `ThisContext` and whose body is the condition of this conditional breakpoint.
	The goal is to rewrite this AST so that evaluating the block by passing it a context as argument will evaluate its body as it would have been evaluated in the passed context.
	To do this, we rewrite anAST following these three rules:
	1) Rewriting references to undeclared variables into context lookup
		For example, a reference to a variable named flower is rewritten into `ThisContext lookupSymbol: #flower`
	2) Rewriting references to `thisContext` into references to `ThisContext`
	3) Rewriting references to `self` into references to `ThisContext receiver`"
	semanticallyAnalysedMethodAST := anAST doSemanticAnalysis. "To find which variables are undefined"
	allUndeclaredVariableNodes := (semanticallyAnalysedMethodAST allChildren) select: [:astElem | astElem isVariable and: [astElem isUndeclared]].
	allUndeclaredVariableSymbols := (allUndeclaredVariableNodes collect: [ :varNode | varNode name ]) asSet asArray.
	rewriter := RBParseTreeRewriter new.
	allUndeclaredVariableSymbols withIndexDo: [:tempName :index | 
		rewriter
			"replace: tempName , ' := ``@object' with: 'ThisContext namedTempAt:' , index asString , 'put: ``@object';"
			replace: tempName with: '(ThisContext lookupSymbol: #' , tempName, ')'
	].
   rewriter
		replace: 'thisContext' with: 'ThisContext'.
	rewriter
		replace: 'self' with: 'ThisContext receiver'.
	rewrittenConditionBlockProducerAST := rewriter
		executeTree: semanticallyAnalysedMethodAST;
		tree.
	^ rewrittenConditionBlockProducerAST doSemanticAnalysis.
]
